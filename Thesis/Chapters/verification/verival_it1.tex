\chapter{Verification and Validation}
 Computer simulations are in many engineering applications a cost-efficient way for conducting design and performance optimalization of physical problems. However, thrusting blindly numbers generated from a computer code can prove to be naive. It doesn't take a lot of coding experience before one realizes the many things that can brake down and produce unwanted or unexpected results. 
Therefore, \textit{credability} of computational results are essential, meaning the simulation is worthy of belief or confidence \cite{Oberkampf2010}. \textit{Verification and validation} (V\&V) is the main approach for assessing and the reliability of computational simulations \cite{Sommerville2006}.  A thorough discussion  of (V\&V) concepts and terminology during the last century can be found in \cite{Oberkampf2010}. In this thesis, the definitions provided by the \textit{American Society of Mechanical Engineers guide for Verification and Validation in Computational Solid Mechanics}  \cite{Schwer2006} are followed.

\begin{defn}
Verification: The process of determining that a computational model accurately represents
the underlying mathematical model and its solution. 
\end{defn}

\begin{defn}
Validation: The process of determining the degree to which a model is an accurate
representation of the real world from the perspective of the intended uses of the model. 
\end{defn}

Simplified \textit{verification} considers if one solves the equations right, while \textit{validation} is checking if one solves the right equations for the given problem \cite{Roache}.

 To test a computational code for all possible parameters, conditions and applications are simply too time consuming.   Verification and validation are therefore ongoing processes, with no clear boundary of completeness unless additional requirements are specified \cite{Roache}. The goal of this chapter is to verify our implementations using the method of manufactured solution  (MMS), addressing validation in a later chapter.

\section{Verification of Code}
Within scientific computing a mathematical model is often the baseline for simulations of a particular problem of interest. For scientists exploring physical phenomena, the mathematical model is often on the form of systems of partial differential equations (PDE´s). A computer program therefore must evaluate  mathematical identities such a differential operators and functions in order to produce accurate solutions of the governing PDE´s. 
Through verification of code, the ultimate goal is to ensure a computer program truly represents the mathematical model. To accumulate sufficient evidence that a mathematical model is solved correctly by a computer code,  it must excel within predefined criteria. If the acceptance criterion is not satisfied, a coding mistake is suspected. Should the code pass the preset criteria, the code is considered verified. Of the different classes of test found in \cite{Roache},  \textit{Order-of-accuracy} (OAA)  is regarded as the most rigorous acceptance criterion for verification \cite{Biggs}, \cite{Roache}, \cite{Etienne2006}. In addition to error estimation and convergence of the numerical solution, the method ensure the discretization error $E$ is reduced in coordinance with the \textit{formal order of accuracy} expected from the numerical scheme. The formal order of accuracy is defined to be the theoretical rate at which the truncation error of a numerical scheme is expected to reduce. The \textit{observed order of accuracy} is the actual rate produced by our code. The order of convergence is calculated  xAssuming a PDE of space and time, order-of-accuracy tests are conducted separatly of 

By monitoring the dicretization error $E$ by spatial and temporal refinements, one assumes the asymptotic behavior,

\begin{align*}
&E = E_x + E_t = u_e - u_h = C\Delta t^p + D\Delta x^l\\
\end{align*} 
where C is a constant, h represents the spatial or temporal resolution, and p is the convergence rate of the numerical scheme. For order of convergence tests, the code is assumed to be verified if the discretization error is proportional to $h^p$.

\subsection{Method of manufactured solution}
The basis of a convergence test is how to find an exact/reference solution, in order to compute the discretization error $E$. However solutions of PDE´s are limited, and often simplifications of the original problem are needed to produce analytically solutions.  \textit{The method of manufactured solutions} provides a simple yet robust way of making analytic solutions for PDE´s. 
Let a  partial differential equation of interest be on the form
\begin{align*}
\textbf{L}(\textbf{u}) = \textbf{f}
\end{align*}

Here \textbf{L} is a differential operator, \textbf{u} is variable the of interest, and \textbf{f} is some sourceterm. In the method of manufactured solution one first manufactures a solution \textbf{u} for the given problem. In general, the choice of \textbf{u} will not satisfy the governing equations, producing a sourceterm  \textbf{f} after differentiation by \textbf{L}. The produced source term will cancel any imbalance formed by the manufactured solution \textbf{u} of the original problem. Therefore, the manufactured solution can be constructed without any physical reasoning, proving code verificaion as a purely a mathematical exercise were our only interest is to verify the solution \cite{Roache2002}. If the MMS is not chosen properly the test will not work, therfore some guidelines for rigirous verification have been proposed in \cite{Etienne2006, Biggs, Roache2002}. 

\begin{itemize}
\item The manufactured solution (MS), should be composed of smooth analytic functions such as exponential, trigonometric, or polynomials.
\item The MS should should have sufficient number of derivatives, exercising all terms and derivatives of the PDE´s. 
\end{itemize}

To deeply verify the robustness of the method of manufactured solution,  a report regarding code verification by MMS for CFD was published by Salari and Knupp \cite{Biggs}. This thorough work applied the method for both compressible and incompressible time-dependent Navier-Stokes equation. To prove its robustness the authors deliberate implemented  code errors in a verified Navier-Stokes solver by MMS presented in the report. In total 21 blind testcases where implemented, where different approaches of verification frameworks were tested. 
Of these, 10 coding mistakes that reduces the observed order-of-accuracy was implemented. Here the method of manufactured solution captured all coding mistakes, except one. This mistake would, accordingly to the co-author , been captured if his guidelines for conducting MMS had been followed. 
In general, computing the source term f can be quite challenging and error prone.  Therefore, symbolic computation of the sourcterm is advantigous to overcome mistakes which can easily occur when calulating by hand. For construction of the sourceterm \textbf{f}, the Unified Form Language (UFL)  \cite{Alnæs2015} provided in FEniCS Project will be used. 

\subsection{Verification of the fluid-structure interaction solver by MMS}
In general the MMS does not need to match any physical capabilities. However, when considering multiphysics problems, such as FSI, the equations has to meet the mathematical criteria of the interface.
\begin{enumerate}
\item Kinematic boundary condition $\bat{v}_s = \bat{v}_f$, enforced strongly by a continious velocity field in the fluid
        and solid domain.
\item Dynamic boundary condition $\sigma_s \cdot \mathbf{n}= \sigma_f \cdot \mathbf{n}$, enforced weakly by omitting the 
        boundary integrals from the weak formulation in problem.
\end{enumerate}
The choice of a MMS is therefore not trivial, as it must fulfill condition 1 and 2, in addition to the divergence-free condition in the fluid, and avoiding cancellation of the ALE-convective term $/pder{\hat{T}_f}{t}$.  The struggle is reflected of the abscence of research, regarding MMS for coupled FSI solvers in the litterature. The challenge are often disregarded, such as \cite{Sheldon2014}, where the verification process is conducted on the fluid and structure solver separately. Instead, the correctness of the coupling is evaluated by the code validation. The approach clearly ease the process, assuming verification of each codeblock is "sufficient" to declare the code verified. It must be stressed that solving each problem individually is not true verification, in reference to a monolithic approach where the problems are solved at the same time.\\The construction of a MMS for a monolithic FSI problem is therefore out of the scope of this thesis. Conducting verification on the fluid and structure separatly is not , but considered "good enough" to show the mathematical model is discretized accuratly.

\section{Validation}
Through \textit{verification}, one can assure that a scientific code implements a mathematical model correctly. However, c
orrectness is unnecessarly, if the model fails to serve as an accurate representation of the physical problem of interest. 
By definition 1.2, \textit{Validation} is the act of demonstrating that a mathematical model is applicable for its intended use with a certain degree of accuracy. This demonstration is not intended to portray the model as an absolute truth, nor the best model available \cite{Rykiel1996}. \\
The acceptence criteria of validation is based on the numerical solution produced, by comparison with existing experiment data. The dependency of thrusting experiments, makes \textit{validation} assess a wide range of issuses \cite{Sommerville2006} 
\begin{itemize}
\item The relevance of mathematical model compared to the experiment.
\item Assurence of that the experiments was conducted correctly, in accordinance with prescribed 
        parameters, initial and boundary conditions e.t
\item Uncertainty of experimental measurements
\end{itemize}

Comparing numerical results with existing experiments,raise some issues in the validation process. First, reproducing of experimental resuts...  









 

